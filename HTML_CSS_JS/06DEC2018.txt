typeof로는 타입확인 밖에 안된다 --> JS 객체는 모두 function OR object 타입이다
정확히 어떤 타입의 객체인지 알려면 instanceof 사용해야
JS에서도 다형성 적용 --> 모든 객체나 함수는 instanceof Object하면 true 반환 --> 모두 Object의 자손이다
JS에서는 클래스가 없다 --> 대신 생성자가 클래스와 비슷한 역할 --> instanceof Object라고 치면, 여기서 Object는 Object 생성자를 의미

같은 타입의 객체라도 함수를 공유하지 않는다 -> prototype, __proto__, constructor 사용
모든 생성자는 prototype 객체를 가지고 있다
같은 생성자에 의해 만들어진 서로다른 객체는 서로 constructor가 같다 --> 서로 __proto__가 같다 --> 둘 다 같은 생성자의 prototype을 참조한다 --> 한 생성자에 의해 만들어진 서로다른 객체는 똑같은 생성자의 prototype의 데이터를 공유한다
같은 생성자로부터 만들어진 서로 다른 객체들이 공통으로 사용할 수 있는 데이터를 주려면, prototype에 해당 데이터를 추가한다 --> JS에서 상속 개념이 없다보니까 이렇게 우회한 것
객체의 특정 속성을 찾으면, 일단 객체의 속성을 찾고 못찾으면 prototype에서 찾아본다 --> "prototype chaining"

this
브라우저 자신 OR 객체 자신을 의미
new 연산자 안 붙이면 this는 객체 자신이 아닌 브라우저 지칭
new연산자에 의해 객체 생성, THEN 생성자에 의해 속성 추가
객체 생성 & 속성 추가를 따로 하려면 (i.e. 객체를 생성 후 생성자 적용을 나중에하려면) <생성자명>.<call>(<target 객체>, <생성자 매개변수1>, <생성자 매개변수2>...) OR <생성자명>.<apply>(<target 객체>, [<생성자 매개변수1>, <생성자 매개변수2>...]) 사용해야 한다.
사실 call & apply는 생성자 외 다른 것에도 사용할 수 있다!!!!!

JS의 생성자 : 객체에 속성을 추가해주는 함수; 일반적으로 new와 함께 사용되어 객체 생성과 속성 추가를 동시에 함; 이미 생성된 객체에 생성자를 적용하려면 call() OR apply()를 사용하면 된다 --> 객체는 원래 객체를 유지한다! 속성과 속성의 값만 추가할 뿐! --> 상속관계를 맺어서 해결
var p = {}; // 빈 객체 생성
Person.call(p, "abc", "123"}; // 객체 p에 생성자 적용 ("abc", "123"은 생성자의 매개변수)

JS는 접근제어자가 없다 -> 대신 지역변수로 만들어서 외부에서의 접근을 차단, 그리고 getter-setter를 사용한다

상속관계를 만들려면 child의 생성자에서 parent의 생성자를 call하고 AND parent의 prototype을 child의 prototype에 대입해야 한다
기본적으로 모든 생성자로 만들어낸 객체는 Manager.prototype.__proto__ === Object.prototype --> 객체의 __proto__는 Object의 prototype을 가리킨다는 것
상속관계가 되려면 Manager.prototype.__proto__ === Person.prototype으로 child의 __proto__가 parent의 prototype을 가리키게 만들어야 한다
Manager.prototype = Person.prototype <-- 이것은 안된다!!!!
Manager.prototype.__proto__ = Person.prototype <-- 이렇게 해야 한다!!!!
prototype은 객채, __proto__는 객체를 가리키는 참조변수
